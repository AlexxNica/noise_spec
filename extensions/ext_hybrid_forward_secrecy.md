---
title:      'Noise Extension: Hybrid Forward Secrecy'
author:     'Rhys Weatherley (rhys.weatherley@gmail.com)'
revision:   '1draft-2'
date:       '2016-09-25'
---

1. Motivation
=============

Once quantum computers become available it is possible that existing
Noise DH algorithms such as `25519` and `448` will become vulnerable.
This might allow a future adversary armed with a quantum computer to
read archived communications.

Using currently-known post-quantum cryptography we may be able to
strengthen the secrecy of current communications against future adversaries.

This document describes an extension to the Noise protocol to augment
handshakes with additional forward secrecy.  We describe the general
method here.  Separate extensions will describe specific post-quantum
algorithms.

For demonstration purposes, we assume that `448` is being used to
strengthen a `25519` handshake.  This allows us to describe the minimum
changes necessary to Noise to add extra forward secrecy to a handshake
using existing Noise primitives.  In a practical implementation,
`448` would of course be replaced by a post-quantum algorithm.

2. Protocol naming
==================

The name of the DH function in the protocol name is modified to
include a pair of identifiers separated by a plus sign; for example:

    Noise_XXhfs_25519+448_AESGCM_SHA256

The pattern name `XXhfs` indicates that that pattern `XX` has been
transformed using the "hybrid forward secrecy" transformation, which
is defined later.

The function for the first name in the pair (`25519`) plays the same
role as in regular Noise.  The function for the second name in the pair
(`448`) specifies the algorithm that will be used to add hybrid forward
secrecy to an otherwise plain `Noise_XX_25519_AESGCM_SHA256` handshake.

If a protocol name includes a hybrid forward secrecy function, then the
pattern must include the `"f"`, `"g"`, and `"fg"` tokens described
later.  Otherwise the protocol name is invalid.

Conversely, a pattern that includes `"f"`, `"g"`, and `"fg"` tokens
can only be used with a protocol name that includes a hybrid forward
secrecy function.

3. Crypto functions
===================

The following functions and constant definitions are added to Noise:

 * **`GENERATE_KEYPAIR_F()`**: Generates a new key pair for the hybrid
   forward secrecy algorithm.

 * **`GENERATE_KEYPAIR_G(r)`**: Generates a new key pair for the
   hybrid forward secrecy algorithm relative to a remote public key `r`.

 * **`MIX_FG(key_pair, public_key)`**: Performs a calculation for the hybrid
   forward secrecy algorithm that mixes a local key pair with a remote
   public key.

 * **`FLEN`** = A constant specifying the size in bytes of the output
   from `GENERATE_KEYPAIR_F()`.

 * **`GLEN`** = A constant specifying the size in bytes of the output
   from `GENERATE_KEYPAIR_G()`.

 * **`FGLEN`** = A constant specifying the size in bytes of the output
   from `MIX_FG()`.

This extension uses these functions to generate and operate with
ephemeral keys only.

When a traditional Noise DH function like `448` is used to provide
hybrid forward secrecy, the above definitions are specified as follows:

 * `GENERATE_KEYPAIR_F()` = `GENERATE_KEYPAIR()`
 * `GENERATE_KEYPAIR_G(r)` = `GENERATE_KEYPAIR()`
 * `MIX_FG(key_pair, public_key)` = `DH(key_pair, public_key)`
 * `FLEN` = `GLEN` = `FGLEN` = `DHLEN`

The separate extension for the post-quantum New Hope algorithm specifies
the above definitions as follows:

 * `GENERATE_KEYPAIR_F()` = `newhope_keygen()`
 * `GENERATE_KEYPAIR_G(r)` = `newhope_sharedb(r)`
 * `MIX_FG(key_pair, public_key)` = `newhope_shareda(key_pair, public_key)`
   if the `key_pair` was generated by `GENERATE_KEYPAIR_F()`.
 * `MIX_FG(key_pair, public_key)` = `key_pair.shared` if the `key_pair`
   was generated by `GENERATE_KEYPAIR_G()`.
 * `FLEN` = 1824
 * `GLEN` = 2048
 * `FGLEN` = 32

As can be seen, New Hope has different key sizes and behaviors for
the two parties `f` (Alice) and `g` (Bob).  This asymmetric algorithm
shape motivated splitting hybrid forward secrecy into separate operations
on `"f"` and `"g"`.

4. Changes to HandshakeState
============================

4.1. Variables
--------------

Two extra variables are added to the state:

 * `f`: The local hybrid forward secrecy key pair.
 * `rf`: The remote party's hybrid forward secrecy public key.

Both of these variables are instances of the second function from
the protocol name.  If the protocol name does not include a second
function, then the `f` and `rf` variables are not used by the
handshake.

4.2. Initialization
-------------------

`Initialize()` is modified to include `f` and `rf` parameters.  If either
value is supplied as a pre-message then that value must be hashed
during the fourth pre-message step of the handshake.

Pre-messages are hashed in the order `e`, `f`, `s`, initiator values first.
The set of valid pre-messages is:

 * `e`
 * `s`
 * `e, s`
 * `e, f`
 * `e, f, s`

4.3. Tokens
-----------

Three new tokens are added for use in defining message patterns:
`"f"`, `"g"`, and `"fg"`.  All other tokens continue to operate as before.

Token handling for `WriteMessage()` is modified as follows:

 * For `"f"`:  Sets `f = GENERATE_KEYPAIR_F()`, overwriting any previous
   value for `f`.  Appends `EncryptAndHash(f.public_key)` to the buffer.

 * For `"g"`:  Sets `f = GENERATE_KEYPAIR_G(rf)`, overwriting any previous
   value for `f`.  Appends `EncryptAndHash(f.public_key)` to the buffer.

 * For `"fg"`:  Calls `MixKey(MIX_FG(f, rf))`.

Token handling for `ReadMessage()` is modified as follows:

 * For `"f"`: Sets `temp` to the next `FLEN + 16` bytes of the message if
   `HasKey() == True`, or to the next `FLEN` bytes otherwise.  Sets `rf`
   to `DecryptAndHash(temp)`.  

 * For `"g"`: Sets `temp` to the next `GLEN + 16` bytes of the message if
   `HasKey() == True`, or to the next `GLEN` bytes otherwise.  Sets `rf`
   to `DecryptAndHash(temp)`.  

 * For `"fg"`:  Calls `MixKey(MIX_FG(f, rf))`.

Note that the `"f"` and `"g"` token values will be encrypted if a
`"dhxy"` token has already been seen in the pattern, or if pre-shared
keys are involved.

4.4. Handling of pre-shared keys
--------------------------------

The standard Noise specification modifies `Initialize()` and the handling
of the `"e"` token to mix the pre-shared key with the handshake state,
using the value of `e.public_key` as a random nonce.

This behavior is retained when hybrid forward secrecy is in use.  Operations
involving `e` are modified but operations involving `f` are not modified.
The `e.public_key` value should be sufficient as a random nonce on its own.

Some post-quantum algorithms may wish to reuse `f` or parts of `f` between
sessions because of the expense of generating the value.  This means that
`f` may not contain enough randomness to be an effective session nonce.

5. Message patterns for hybrid forward secrecy
==============================================

5.1. The `hfs` pattern transformation
-------------------------------------

This extension defines a transformation named `hfs` that modifies an
existing interactive pattern into one involving hybrid forward secrecy.
The transformation rules are:

 * The first occurrence of the `"e"` token is replaced with `"e, f"`.
 * The second occurrence of the `"e"` token is replaced with `"e, g"`.
 * If `"e"` appears in the pre-message, then it is considered the first
   occurrence of the `"e"` token and the next occurrence in the pattern
   body is replaced with `"e, g"`.
 * All occurrences of the `"dhee"` token are replaced with `"dhee, fg"`.
 * If the pattern contains `"e"` in its pre-message, then `"f"` is added
   to the pre-message.
 * If the pattern contains `"re"` in its pre-message, then `"rf"` is added
   to the pre-message.

The following examples demonstrate the transformation:

    Noise_NNhfs():
      -> e, f
      <- e, g, dhee, fg

    Noise_XXhfs(s, rs):
      -> e, f
      <- e, g, dhee, fg, s, dhse
      -> s, dhse

    Noise_IKhfs(s, rs):
      <- s
      ...
      -> e, f, dhes, s, dhss
      <- e, g, dhee, fg, dhes

    Noise_XXfallback+hfs(s, rs, re, rf):
      <- e, f
      ...
      -> e, g, dhee, fg, s, dhse
      <- s, dhse

When pattern transformations are composed, we use a plus sign as a separator,
mirroring the practice for DH function names.  The transformations should
be listed in the order in which they are applied to a basic pattern.
If the order doesn't matter, then the parties will need to agree on a
canonical ordering for the purpose of choosing a common protocol name.

5.2. Pattern validity
---------------------

The following validity rules apply:

 * If `f` or `rf` appears as a pre-message in a pattern, then the
   corresponding `e` or `re` value must also appear as a pre-message.
 * `"f"` or `"g"` tokens for a party must always appear after the
   corresponding `"e"` token for that party.
 * Only a single `"f"` or `"g"` token can be sent by each party.
   Alternatively, a pre-message `f` or `rf` value for a party can stand
   in for the token.
 * The `"g"` token must appear after the `"f"` token or pre-message.
 * `"fg"` must occur only once in the pattern, after both `"f"` and `"g"`
   or their pre-message counterparts.
 * `"fg"` must occur after `"dhee"`.

5.3. Hybrid pattern list
------------------------

Standard interactive Noise patterns that are transformed with `hfs` fall
into two broad categories: fully hybrid and partially hybrid.

Fully hybrid patterns are those where the first two mixing operations
in the pattern are `"dhee"` and `"fg"`.  All values that would have been
encrypted in the original pattern are now encrypted with a hybrid key
combining outputs from both algorithms.  Any message payloads and
static public key values that were previously sent in the clear are
still in the clear.

The following patterns are fully hybrid:

    Noise_NNhfs():
      -> e, f
      <- e, g, dhee, fg

    Noise_NXhfs(rs):
      -> e, f
      <- e, g, dhee, fg, s, dhse

    Noise_XNhfs(s):
      -> e, f
      <- e, g, dhee, fg
      -> s, dhse

    Noise_XXhfs(s, rs):
      -> e, f
      <- e, g, dhee, fg, s, dhse
      -> s, dhse

    Noise_KNhfs(s):
      -> s
      ...
      -> e, f
      <- e, g, dhee, fg, dhes

    Noise_KXhfs(s, rs):
      -> s
      ...
      -> e, f
      <- e, g, dhee, fg, dhes, s, dhse

    Noise_INhfs(s):
      -> e, f, s
      <- e, g, dhee, fg, dhes

    Noise_IXhfs(s, rs):
      -> e, f, s
      <- e, g, dhee, fg, dhes, s, dhse 

    Noise_XXfallback+hfs(s, rs, re):                   
      <- e, f
      ...
      -> e, g, dhee, fg, s, dhse
      <- s, dhse

    Noise_NXnoidh+hfs(rs):
      -> e, f
      <- e, g, s, dhee, fg, dhse

    Noise_XXnoidh+hfs(s, rs):
      -> e, f
      <- e, g, s, dhee, fg, dhse
      -> s, dhse

    Noise_KXnoidh+hfs(s, rs):
      -> s
      ...
      -> e, f
      <- e, g, s, dhee, fg, dhes, dhse

    Noise_IXnoidh+hfs(s, rs):
      -> e, f, s
      <- e, g, s, dhee, fg, dhes, dhse

Partially hybrid patterns are those where a `"dhxy"` operation involving a
static public key precedes the first `"dhee"` operation.  Static public
key values and message payloads that precede the first `"fg"` operation
will be encrypted only with the classical DH algorithm.  If that algorithm
falls to a future attack, then message payloads or static public keys that
were previously encrypted may be revealed.

The following patterns are partially hybrid:

    Noise_NKhfs(rs):
      <- s
      ...
      -> e, f, dhes
      <- e, g, dhee, fg

    Noise_XKhfs(s, rs):
      <- s
      ...
      -> e, f, dhes
      <- e, g, dhee, fg
      -> s, dhse

    Noise_KKhfs(s, rs):
      -> s
      <- s
      ...
      -> e, f, dhes, dhss
      <- e, g, dhee, fg, dhes

    Noise_IKhfs(s, rs):
      <- s
      ...
      -> e, f, dhes, s, dhss
      <- e, g, dhee, fg, dhes

    Noise_IKnoidh+hfs(s, rs):
      <- s
      ...
      -> e, f, s, dhes, dhss
      <- e, g, dhee, fg, dhes

As can be seen, all of the standard interactive patterns that end in
`"K"` become partially hybrid when transformed with `hfs`.

It is disappointing that `"IK+hfs"` is partially hybrid because it means
that a post-quantum Noise Pipes is not a simple matter of transforming
`"XX"`, `"IK"`, and `"XXfallback"` with `hfs`.

6. Future Directions
====================

6.1. Other hybrid patterns
--------------------------

Partially hybrid patterns can be improved by using another transformation
to move static public key values to later in the handshake to hide identity
information:

    Noise_IKhfs+xyz(s, rs):
      <- s
      ...
      -> e, f, dhes
      <- e, g, dhee, fg
      -> s, dhss, dhse

The `"dhes"` token in the first message could also be moved to the
third message.  Although for Noise Pipes we would like the first
message to trigger fallback if the initiator is not in possession
of the responder's current static public key.  The responder's static
public key value is not as secret as the initator's - any party can
connect to the responder with `"XX"` and retrieve the responder's
static public key without needing to mount an attack against archived
communications.

Transforming patterns in this way tends to increase the number of
turn-arounds.  More experimentation is required before such a
transformation can be standardized.  This extension provides the basic
tools that could be used to define such a transformation later.

Other transformations are also possible for hybrid forward secrecy.
The New Hope algorithm allows for Alice to generate a public "a" value
that persists between sessions for a limited time.  This saves the expense
of regenerating "a" for each session.  It thus naturally makes sense for
Alice to be the server/responder rather than the client/initiator:

    Noise_XXreversehfs(s, rs):
      -> e
      <- e, f, dhee, s, dhse
      -> g, fg, s, dhse

As before, other tokens may need to be moved to be covered by the
hybrid forward secrecy so as to create a useful pattern.

6.2. Encryption of hybrid forward secrecy values
------------------------------------------------

Given that post-quantum cryptography is very new, it is possible that
weaknesses may be found in whatever algorithm is chosen.  Encryption
of `"f"` and `"g"` tokens can help hide patterns in the post-quantum
values that might allow cryptanalysis.

Encryption of `"f"` and `"g"` tokens may also be useful for implementing
an Elligator-like scheme that converts post-quantum values into something
indistinguishable from random.

The `hfs` transformation does not encrypt the `"f"` and `"g"` values in
fully hybrid patterns but does encrypt the `"g"` value in partially hybrid
patterns.  A modified transformation may be able to do better.

6.3. Post-quantum static keys
-----------------------------

This extension is solely concerned with augmenting the forward
secrecy of an existing handshake.  It is possible to imagine a further
extension whereby the hybrid function also operates on static keys.

Some post-quantum algorithms like New Hope only support ephemeral
keys, whereas others like SIDHp751 support both ephemeral and
static keys.  Static keys could be handled in one of two ways:

 * Use `25519` or `448` for hybrid forward secrecy, and the post-quantum
   algorithm for static keys; e.g. `Noise_XXhfs_SIDHp751+448`.
 * Extend the facilities here with new tokens to allow static keys for
   both algorithms; e.g. `Noise_XXhfs+hstatic_448+SIDHp751`.

At the moment we do not make any comment as to the wisdom in doing so
or the mechanisms that would be involved.
